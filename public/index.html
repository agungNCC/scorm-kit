<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <title>File Slide Viewer - Editor</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="stylesheet" href="css/styles.css" />
    <script src="js/Config.js" type="text/javascript"></script>

    <!-- PDF.js -->
    <script src="js/pdf.min.js" type="text/javascript"></script>
    <script>pdfjsLib.GlobalWorkerOptions.workerSrc = "js/pdf.worker.min.js";</script>
</head>

<body>
    <!-- TOP BAR -->
    <div class="topbar">
        <div class="topbar-menu" id="toggleTocBtn">&#9776;</div>
        <div id="header-title" class="topbar-title"></div>

        <div style="margin-left:auto; display:flex; align-items:center; gap:10px;">
            <div style="font-size:12px; opacity:0.9; color:rgba(255,255,255,0.9);" id="status">ready</div>

            <label id="uploadLabel" title="Upload file"
                style="cursor:pointer; padding:6px 10px; border-radius:4px; background:rgba(255,255,255,0.06); color:inherit; font-size:13px;">
                Upload
                <input id="fileInput" type="file" accept=".pdf,.ppt,.pptx" style="display:none" />
            </label>

            <button id="openUploadConfigBtn" title="Upload settings" style="cursor:pointer; padding:6px 10px; border-radius:4px;
                    background:rgba(255,255,255,0.06); color:inherit;
                    font-size:13px; border:none;">
                ⚙️
            </button>


            <button id="downloadScormBtn" title="Download SCORM package"
                style="margin-left:8px; padding:6px 10px; border-radius:4px;">Download SCORM</button>
        </div>
    </div>

    <!-- MAIN LAYOUT -->
    <div class="main-layout">
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <span>Table of Contents</span>
                <span class="sidebar-close" id="closeTocBtn">&times;</span>
            </div>
            <ul class="page-list" id="pageList"></ul>
        </aside>

        <section class="viewer">
            <div class="canvas-wrapper">
                <canvas id="pdfCanvas"></canvas>
            </div>
        </section>
    </div>

    <!-- BOTTOM BAR -->
    <div class="bottombar">
        <div class="progress-section">
            <div class="progress-bar-container">
                <div class="progress-bar-fill" id="progressBarFill"></div>
            </div>
            <div class="progress-text" id="progressText">0% completed</div>
        </div>

        <div class="page-info-wrapper">
            <button class="nav-btn" id="prevBtn">Prev</button>
            <span id="pageInfo" class="page-info">Page 1 / 1</span>
            <button class="nav-btn primary" id="nextBtn">Next</button>
        </div>
    </div>

    <!-- Upload Config Modal -->
    <div id="uploadConfigModal" class="modal hidden">
        <div class="modal-content">
            <h3>Upload Content</h3>

            <label>
                Title
                <input type="text" id="uploadTitle" placeholder="Title" />
            </label>

            <label class="checkbox">
                <input type="checkbox" id="uploadSidebarOpen" />
                Sidebar Default Open
            </label>

            <label class="checkbox">
                <input type="checkbox" id="uploadSlideLocked" />
                Slide Sequence Locked
            </label>

            <div class="modal-actions">
                <button id="uploadCancelBtn">Cancel</button>
                <button id="uploadOkBtn" class="primary">OK</button>
            </div>
        </div>
    </div>


    <!-- SCORM helpers -->
    <script>
        let scormAPI = null;
        let scormVersion = null;

        function findAPI(win) {
            let attempts = 0;
            const maxAttempts = 500;
            while (!win.API && !win.API_1484_11 && win.parent && win.parent !== win && attempts < maxAttempts) {
                attempts++; win = win.parent;
            }
            if (win.API) { scormVersion = "1.2"; return win.API; }
            if (win.API_1484_11) { scormVersion = "2004"; return win.API_1484_11; }
            return null;
        }

        function initSCORM() {
            try {
                scormAPI = findAPI(window);
                if (!scormAPI) {
                    console.warn("SCORM API not found. Running standalone.");
                    return;
                }
                if (scormVersion === "1.2") scormAPI.LMSInitialize && scormAPI.LMSInitialize("");
                else scormAPI.Initialize && scormAPI.Initialize("");
            } catch (e) { console.error("SCORM init error:", e); }
        }

        function getSCORMValue(el12, el2004) {
            if (!scormAPI) return "";
            try { if (scormVersion === "1.2") return scormAPI.LMSGetValue(el12) || ""; else return scormAPI.GetValue(el2004) || ""; }
            catch (e) { console.warn("SCORM get error", e); return ""; }
        }
        function setSCORMValue(el12, el2004, value) {
            if (!scormAPI) return;
            try { if (scormVersion === "1.2") scormAPI.LMSSetValue(el12, String(value)); else scormAPI.SetValue(el2004, String(value)); }
            catch (e) { console.warn("SCORM set error", e); }
        }
        function commitSCORM() { if (!scormAPI) return; try { if (scormVersion === "1.2") scormAPI.LMSCommit && scormAPI.LMSCommit(""); else scormAPI.Commit && scormAPI.Commit(""); } catch (e) { } }
        function terminateSCORM() { if (!scormAPI) return; try { if (scormVersion === "1.2") scormAPI.LMSFinish && scormAPI.LMSFinish(""); else scormAPI.Terminate && scormAPI.Terminate(""); } catch (e) { } }
        window.addEventListener("beforeunload", terminateSCORM);

        // Reconcile SCORM status vs suspend_data
        function reconcileScormStatus(totalPagesLocal) {
            if (!scormAPI) return;
            try {
                if (scormVersion === "1.2") {
                    const lessonStatus = scormAPI.LMSGetValue && scormAPI.LMSGetValue("cmi.core.lesson_status") || "";
                    const suspend = scormAPI.LMSGetValue && scormAPI.LMSGetValue("cmi.suspend_data") || "";
                    if (lessonStatus === "completed") {
                        if (!suspend || suspend.length !== totalPagesLocal || /0/.test(suspend)) {
                            try { scormAPI.LMSSetValue("cmi.core.lesson_status", "incomplete"); scormAPI.LMSCommit && scormAPI.LMSCommit(""); } catch (e) { }
                        }
                    }
                } else {
                    const lessonStatus = scormAPI.GetValue && scormAPI.GetValue("cmi.completion_status") || "";
                    const suspend = scormAPI.GetValue && scormAPI.GetValue("cmi.suspend_data") || "";
                    if (lessonStatus === "completed") {
                        if (!suspend || suspend.length !== totalPagesLocal || /0/.test(suspend)) {
                            try { scormAPI.SetValue("cmi.completion_status", "incomplete"); scormAPI.Commit && scormAPI.Commit(""); } catch (e) { }
                        }
                    }
                }
            } catch (err) { console.warn("reconcileScormStatus error:", err); }
        }
    </script>

    <!-- Viewer logic (editor) -->
    <script>
        // state
        let pdfDoc = null;
        let currentPage = 1;
        let totalPages = 0;
        let isRendering = false;
        let currPage = -1;
        let visitedPages = [];

        const canvas = document.getElementById("pdfCanvas");
        const ctx = canvas.getContext("2d");
        const prevBtn = document.getElementById("prevBtn");
        const nextBtn = document.getElementById("nextBtn");
        const pageInfo = document.getElementById("pageInfo");
        const pageList = document.getElementById("pageList");
        const progressBarFill = document.getElementById("progressBarFill");
        const progressText = document.getElementById("progressText");
        const sidebar = document.getElementById("sidebar");
        const toggleTocBtn = document.getElementById("toggleTocBtn");
        const closeTocBtn = document.getElementById("closeTocBtn");
        const headerTitleEl = document.getElementById("header-title");
        const canvasWrapper = document.querySelector(".canvas-wrapper");
        const statusEl = document.getElementById("status");

        if (window.Config && Config.title && headerTitleEl) headerTitleEl.textContent = Config.title;
        function setStatus(text) { if (statusEl) statusEl.textContent = text; console.log("[ViewerStatus]", text); }
        function applyConfigStyles() { if (!window.Config) return; const root = document.documentElement; const map = { "--font-family": Config.fontFamily, "--font-size": Config.fontSize, "--font-color": Config.fontColor, "--body-bg": Config.bodyBgColor, "--topbar-bg": Config.headerBgColor, "--topbar-text": Config.headerTextColor, "--bottombar-bg": Config.footerBgColor, "--bottombar-text": Config.footerTextColor, "--nav-btn-bg": Config.buttonBgColor, "--nav-btn-primary-bg": Config.buttonPrimaryBgColor, "--nav-btn-text": Config.buttonTextColor, "--progress-fill": Config.progressBarColor }; Object.keys(map).forEach(k => { const v = map[k]; if (v !== undefined && v !== null) root.style.setProperty(k, v, "important"); }); }

        function updatePageInfo() { pageInfo.textContent = `Page ${currentPage} / ${totalPages}`; }
        function updateProgressUI() { const visitedCount = visitedPages.filter(Boolean).length; const percent = totalPages ? Math.round((visitedCount / totalPages) * 100) : 0; progressBarFill.style.width = `${percent}%`; progressText.textContent = `${percent}% completed`; }

        function applyUploadConfig() {
            if (!window.UploadConfig) return;

            if (!window.Config) return;

            // title
            const headerTitle = document.getElementById("header-title");
            if (headerTitle) {
                headerTitle.textContent = Config.title || "";
            }

            // sidebar
            if (Config.sidebarDefaultOpen === true && typeof openSidebar === "function") {
                openSidebar();
            }

            // slide lock (flag global)
            window.__SLIDE_SEQUENCE_LOCKED__ = Config.slideSequenceLocked === true;

        }


        function buildPageList() {
            pageList.innerHTML = "";
            for (let i = 1; i <= totalPages; i++) {
                const li = document.createElement("li"); li.className = "page-item"; li.dataset.page = i;
                const icon = document.createElement("span"); icon.className = "toc-icon"; icon.innerHTML = "&#9776;";
                const label = document.createElement("span"); label.className = "page-label"; label.textContent = `Slide ${i}`;
                const status = document.createElement("span"); status.className = "page-status";
                li.appendChild(icon); li.appendChild(label); li.appendChild(status);
                li.addEventListener("click", () => { goToPage(i); if (window.innerWidth < 900) closeSidebar(); });
                pageList.appendChild(li);
            }
            refreshPageListStatus();
        }

        function refreshPageListStatus() {
            const items = pageList.querySelectorAll(".page-item");
            items.forEach(item => {
                const page = parseInt(item.dataset.page, 10);
                const visited = visitedPages[page - 1] || false;
                item.classList.toggle("active", page === currentPage);
                const statusSpan = item.querySelector(".page-status");
                statusSpan.classList.remove("visited", "not-visited");
                if (visited) { statusSpan.classList.add("visited"); statusSpan.textContent = "✔"; } else { statusSpan.classList.add("not-visited"); statusSpan.textContent = "●"; }
            });
        }

        // page render
        function renderPage(pageNumber) {
            if (!pdfDoc || isRendering) return;
            if (currPage === pageNumber) return;
            currPage = pageNumber;
            isRendering = true;
            pdfDoc.getPage(pageNumber).then(page => {
                const wrapper = canvasWrapper;
                const unscaledViewport = page.getViewport({ scale: 1 });
                const pdfWidth = unscaledViewport.width, pdfHeight = unscaledViewport.height;
                let scale = Math.min(wrapper.clientWidth / pdfWidth, wrapper.clientHeight / pdfHeight);
                if (!isFinite(scale) || scale <= 0) scale = 1;
                const viewport = page.getViewport({ scale });
                canvas.width = viewport.width; canvas.height = viewport.height;
                const renderContext = { canvasContext: ctx, viewport: viewport, transform: [1, 0, 0, 1, 0, 0] };
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                page.render(renderContext).promise.then(() => {
                    isRendering = false; markPageVisited(pageNumber);
                }).catch(e => { console.error("Render error:", e); isRendering = false; });
            });
            prevBtn.disabled = pageNumber <= 1;
            nextBtn.disabled = pageNumber >= totalPages;
            updatePageInfo(); refreshPageListStatus();
        }

        function goToPage(pageNumber) {
            if (pageNumber < 1 || pageNumber > totalPages) return; currentPage = pageNumber; renderPage(currentPage);
        }

        function markPageVisited(pageNumber) {
            // mark only after successful render
            if (!visitedPages[pageNumber - 1]) visitedPages[pageNumber - 1] = true;
            updateProgressUI(); refreshPageListStatus(); saveProgressToSCORM();
        }

        // UI toggles
        function openSidebar() { sidebar.classList.add("open"); }
        function closeSidebar() { sidebar.classList.remove("open"); }
        function toggleSidebar() { sidebar.classList.toggle("open"); }

        toggleTocBtn.addEventListener("click", toggleSidebar);
        closeTocBtn.addEventListener("click", closeSidebar);
        document.addEventListener("click", (e) => { if (!sidebar.classList.contains("open")) return; const clickInsideSidebar = sidebar.contains(e.target); const clickOnToggle = toggleTocBtn.contains(e.target); if (!clickInsideSidebar && !clickOnToggle && window.innerWidth < 900) closeSidebar(); });

        prevBtn.addEventListener("click", () => { if (currentPage > 1) goToPage(currentPage - 1); });
        nextBtn.addEventListener("click", () => { if (currentPage < totalPages) goToPage(currentPage + 1); });

        function looksLikePdfByExtension(url) { try { const u = new URL(url); return /\.pdf(\?.*)?$/i.test(u.pathname) || /\.pdf$/i.test(u.pathname); } catch (e) { return /\.pdf(\?.*)?$/i.test(url) || /\.pdf$/i.test(url); } }
        async function headContentTypeIsPdf(url) { try { const resp = await fetch(url, { method: "HEAD" }); const ct = resp.headers.get("content-type") || ""; return ct.toLowerCase().includes("application/pdf"); } catch (e) { console.warn("HEAD request failed", e); throw e; } }
        function isSameOrigin(url) { try { const u = new URL(url, window.location.href); return u.origin === window.location.origin; } catch (e) { return false; } }

        // Decide how to get PDF (direct/proxy/convert)
        async function fetchConvertedPdfUrl(source) {
            const src = source || (window.Config && Config.pptUrl) || null;
            if (!src) throw new Error("No source specified");
            if (src.startsWith("data:") || src.startsWith("blob:")) return src;
            if (looksLikePdfByExtension(src)) { if (isSameOrigin(src)) { setStatus("Detected File (same-origin) — loading directly"); return src; } else { setStatus("Detected File (external) — proxying"); return `/proxy?url=${encodeURIComponent(src)}`; } }
            try { setStatus("Checking content-type of source..."); const isPdf = await headContentTypeIsPdf(src); if (isPdf) { if (isSameOrigin(src)) { setStatus("Detected File by content-type — loading directly"); return src; } else { setStatus("Detected File by content-type — proxying"); return `/proxy?url=${encodeURIComponent(src)}`; } } } catch (e) { setStatus("Could not verify content-type (CORS?) — will try convert"); }
            setStatus("Requesting server to convert to File...");
            const resp = await fetch(`/render?url=${encodeURIComponent(src)}`, { method: "GET", headers: { Accept: "application/json" } });
            if (!resp.ok) { const txt = await resp.text().catch(() => ""); throw new Error(`Server returned ${resp.status} ${txt}`); }
            const j = await resp.json();
            if (!j.pdf) throw new Error("Server response missing 'pdf' field");
            setStatus("Server converted to File");
            return j.pdf;
        }

        // START viewer with pdfUrl
        async function startViewerWithPdf(pdfUrl) {
            try {
                setStatus("Preparing to load File...");
                const cacheBusted = pdfUrl + (/\?/.test(pdfUrl) ? "&" : "?") + "_=" + Date.now();

                try { if (pdfDoc && typeof pdfDoc.destroy === "function") pdfDoc.destroy(); } catch (e) { }
                pdfDoc = null; currPage = -1; isRendering = false; currentPage = 1; totalPages = 0; visitedPages = []; ctx.clearRect(0, 0, canvas.width || 0, canvas.height || 0); pageList.innerHTML = ""; updatePageInfo(); updateProgressUI(); refreshPageListStatus();

                //setStatus("Loading File...");
                setStatus("");

                const loadingTask = pdfjsLib.getDocument(cacheBusted);
                const pdf = await loadingTask.promise;
                pdfDoc = pdf;
                totalPages = pdf.numPages;
                visitedPages = Array(totalPages).fill(false);

                // SCORM init & restore
                initSCORM();
                try {
                    const suspend = getSCORMValue("cmi.suspend_data", "cmi.suspend_data");
                    if (suspend && suspend.length === totalPages) visitedPages = suspend.split("").map(c => c === "1");
                    else visitedPages = Array(totalPages).fill(false);

                    const lastLocation = parseInt(getSCORMValue("cmi.core.lesson_location", "cmi.location"), 10);
                    if (!isNaN(lastLocation) && lastLocation >= 1 && lastLocation <= totalPages) currentPage = lastLocation; else currentPage = 1;

                    // reconcile LMS status (prevent false completed)
                    reconcileScormStatus(totalPages);
                } catch (e) { console.warn("SCORM restore error", e); }

                buildPageList(); updateProgressUI(); updatePageInfo(); renderPage(currentPage);

                window.lastLoadedPdfUrl = pdfUrl;

                // APPLY CONFIG AFTER VIEWER READY
                applyUploadConfig();
                setStatus("Ready");
            } catch (err) {
                console.error("Failed to load File:", err);
                setStatus("Failed to load File");
                ctx.clearRect(0, 0, canvas.width || 0, canvas.height || 0);
                try { ctx.font = "14px sans-serif"; ctx.fillStyle = "#333"; ctx.fillText("Failed to load File.", 10, 30); } catch (e) { }
            }
        }

        // Save progress robustly: only mark completed when truly all pages visited
        function saveProgressToSCORM() {
            if (!totalPages || visitedPages.length !== totalPages) return;
            const dataString = visitedPages.map(v => v ? "1" : "0").join("");
            try {
                setSCORMValue("cmi.suspend_data", "cmi.suspend_data", dataString);
                setSCORMValue("cmi.core.lesson_location", "cmi.location", String(currentPage));
                // only set completed when all visited
                if (visitedPages.every(Boolean)) {
                    setSCORMValue("cmi.core.lesson_status", "cmi.completion_status", "completed");
                } else {
                    // if LMS already had completed but our data not full, set to incomplete to correct (safe guard)
                    const currentStatus = getSCORMValue("cmi.core.lesson_status", "cmi.completion_status");
                    if (currentStatus === "completed") {
                        setSCORMValue("cmi.core.lesson_status", "cmi.completion_status", "incomplete");
                    }
                }
                commitSCORM();
            } catch (e) { console.warn("saveProgressToSCORM error", e); }
        }

        // INIT on load
        window.addEventListener("load", async () => {
            applyConfigStyles();
            setTimeout(() => { }, 50);

            // ===== Upload Config Modal Logic =====
            const uploadLabel = document.getElementById("uploadLabel");
            const uploadModal = document.getElementById("uploadConfigModal");

            const uploadTitleInput = document.getElementById("uploadTitle");
            const uploadSidebarOpenInput = document.getElementById("uploadSidebarOpen");
            const uploadSlideLockedInput = document.getElementById("uploadSlideLocked");

            const uploadOkBtn = document.getElementById("uploadOkBtn");
            const uploadCancelBtn = document.getElementById("uploadCancelBtn");
            const fileInput = document.getElementById("fileInput");

            // ===== Upload Config (Settings) Button =====
            const openUploadConfigBtn = document.getElementById("openUploadConfigBtn");

            // buka modal dari tombol ⚙️
            openUploadConfigBtn.addEventListener("click", () => {
                uploadModal.classList.remove("hidden");
            });


            // Cancel → hide modal
            uploadCancelBtn.addEventListener("click", () => {
                uploadModal.classList.add("hidden");
            });

            // OK → save config → open file browser
            uploadOkBtn.addEventListener("click", () => {
                window.UploadConfig = {
                    title: uploadTitleInput.value || Config.title",
                    sidebarDefaultOpen: uploadSidebarOpenInput.checked,
                    slideSequenceLocked: uploadSlideLockedInput.checked,
                };

                // sinkronkan ke Config (editor runtime)
                if (window.Config) {
                    Config.title = window.UploadConfig.title;
                    Config.sidebarDefaultOpen = window.UploadConfig.sidebarDefaultOpen;
                    Config.slideSequenceLocked = window.UploadConfig.slideSequenceLocked;
                }

                uploadModal.classList.add("hidden");

                applyUploadConfig(); // ⬅️ APPLY LANGSUNG
                //applyConfigStyles();
                //setTimeout(() => { }, 50);
                //fileInput.click();
            });


            // wire upload handler
            //const fileInput = document.getElementById("fileInput");
            fileInput.addEventListener("change", async (e) => {
                const f = e.target.files && e.target.files[0];
                if (!f) return;
                try {
                    setStatus("Uploading...");
                    const fd = new FormData(); fd.append("file", f, f.name);
                    const resp = await fetch("/upload", { method: "POST", body: fd });
                    if (!resp.ok) { const txt = await resp.text().catch(() => ""); throw new Error(txt || resp.statusText); }
                    const j = await resp.json();
                    if (!j.pdf) throw new Error("Server did not return pdf URL");
                    setStatus("Upload successful — loading File");
                    const resolved = await fetchConvertedPdfUrl(j.pdf);
                    await startViewerWithPdf(resolved);
                } catch (err) { console.error("Upload error:", err); alert("Upload failed: " + (err.message || err)); setStatus("Upload failed"); } finally { fileInput.value = ""; }
            });

            // Download SCORM handler
            document.getElementById("downloadScormBtn").addEventListener("click", async () => {
                try {
                    if (!window.lastLoadedPdfUrl) {
                        alert("No File loaded.");
                        return;
                    }

                    setStatus("Preparing SCORM package...");

                    const payload = {
                        pdfUrl: window.lastLoadedPdfUrl,
                        config: {
                            title: Config.title,
                            sidebarDefaultOpen: Config.sidebarDefaultOpen,
                            slideSequenceLocked: Config.slideSequenceLocked
                        }
                    };

                    const resp = await fetch("/package", {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify(payload)
                    });

                    if (!resp.ok) {
                        const txt = await resp.text().catch(() => "");
                        throw new Error(txt || resp.statusText);
                    }

                    const blob = await resp.blob();
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement("a");
                    a.href = url;
                    a.download = "scorm_package.zip";
                    document.body.appendChild(a);
                    a.click();
                    a.remove();
                    URL.revokeObjectURL(url);

                    setStatus("SCORM package ready");
                } catch (err) {
                    console.error("Package download error:", err);
                    alert("Failed to create SCORM package: " + (err.message || err));
                    setStatus("SCORM package failed");
                }

            });

            // decide initial source: Config.filename or Config.pptUrl or sample

            try {
                let pdfToLoad = null;
                const params = new URLSearchParams(window.location.search);
                const qpdf = params.get("pdf");
                if (qpdf) pdfToLoad = qpdf;
                else if (window.Config && Config.filename) pdfToLoad = "data/" + Config.filename;
                else if (window.Config && Config.pptUrl) pdfToLoad = Config.pptUrl;
                else pdfToLoad = null;

                if (!pdfToLoad) { setStatus("No file specified"); return; }
                const resolvedPdf = await fetchConvertedPdfUrl(pdfToLoad);
                await startViewerWithPdf(resolvedPdf);
            } catch (err) { console.error("Init error:", err); setStatus("Initialization error"); alert("Error initializing viewer: " + (err.message || err)); }
        });

        window.addEventListener("resize", () => { renderPage(currentPage); });
    </script>
</body>

</html>